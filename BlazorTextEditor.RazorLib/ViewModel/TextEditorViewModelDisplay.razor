@using BlazorTextEditor.RazorLib.Cursor
@using BlazorTextEditor.RazorLib.HelperComponents
@using BlazorTextEditor.RazorLib.Keymap
@using BlazorTextEditor.RazorLib.Commands
@using System.Collections.Immutable
@using BlazorCommon.RazorLib.Dimensions
@using BlazorTextEditor.RazorLib.Html
@using BlazorTextEditor.RazorLib.Model
@using BlazorTextEditor.RazorLib.ViewModel
@using BlazorTextEditor.RazorLib.ViewModel.InternalComponents

@{
    var textEditorModel = MutableRefModel;
    var textEditorViewModel = MutableRefViewModel;
    var globalTextEditorOptions = TextEditorService.OptionsWrap.Value.Options;

    string fontFamily;

    if (string.IsNullOrWhiteSpace(globalTextEditorOptions.CommonOptions?.FontFamily))
    {
        fontFamily = "monospace";
    }
    else
    {
        fontFamily = globalTextEditorOptions.CommonOptions.FontFamily;
    }

    var fontFamilyCssStyleString =
        $"font-family: {fontFamily};";

    var fontSizeInPixelsCssStyleString = string.Empty;

    if (globalTextEditorOptions.CommonOptions?.FontSizeInPixels is not null)
    {
        fontSizeInPixelsCssStyleString =
            $"font-size: {globalTextEditorOptions.CommonOptions.FontSizeInPixels.Value.ToCssValue()}px;";
    }
}

<div>
    @* Debugging an infinite render loop *@

    <div>@@_renderCounter:&nbsp;@_renderCounter</div>

    @if (textEditorViewModel is not null)
    {
        <div>TextEditorStateChangedKey:&nbsp;@textEditorViewModel.TextEditorStateChangedKey.Guid</div>
    }
    else
    {
        <div>TextEditorStateChangedKey:&nbsp;null</div>
    }

    <hr/>

    @*<div>
        @foreach (var textEditorStateChangedKey in _textEditorStateChangedKeys)
        {
            <div>history:&nbsp;@textEditorStateChangedKey.Guid</div>
        }
    </div>*@
</div>

<div style="@fontSizeInPixelsCssStyleString @fontFamilyCssStyleString @GetGlobalHeightInPixelsStyling() @WrapperStyleCssString"
     class="bte_text-editor-css-wrapper @TextEditorService.ThemeCssClassString @WrapperClassCssString">

    @if (textEditorModel is not null &&
    textEditorViewModel is not null &&
    !globalTextEditorOptions.UseMonospaceOptimizations)
    {
        <div style="display: flex; position: absolute; visibility: hidden;"
             id="@ProportionalFontMeasurementsContainerElementId">
        </div>
    }


    <CascadingValue Value="globalTextEditorOptions">
        <CascadingValue Name="ProportionalFontMeasurementsContainerElementId" Value="ProportionalFontMeasurementsContainerElementId">

            @if (IncludeHeaderHelperComponent &&
            textEditorModel is not null &&
            textEditorViewModel is not null)
            {
                @*
            The CascadingValue for textEditorModel and textEditorViewModel need to be here.
            If outside the if not null checks they can cascade a null value to a component which expects a non null.
            *@
                <CascadingValue Value="textEditorModel">
                    <CascadingValue Value="textEditorViewModel">
                        <TextEditorHeader TextEditorViewModelKey="TextEditorViewModelKey"
                                      HeaderButtonKinds="HeaderButtonKinds" />
                    </CascadingValue>
                </CascadingValue>
            }

            <div @ref="_textEditorDisplayElementReference"
                 @onclick="FocusTextEditorAsync"
                 @onkeydown="HandleOnKeyDownAsync"
                 @onkeydown:preventDefault="true"
                 @oncontextmenu="HandleOnContextMenuAsync"
                 @oncontextmenu:preventDefault="true"
                 @onmousedown="HandleContentOnMouseDownAsync"
                 @onmousemove="HandleContentOnMouseMoveAsync"
                 @ondblclick="HandleContentOnDoubleClickAsync"
                 @onwheel="HandleOnWheelAsync"
                 @ontouchstart="HandleOnTouchStartAsync"
                 @ontouchmove="HandleOnTouchMoveAsync"
                 @ontouchend="ClearTouchAsync"
                 @ontouchcancel="ClearTouchAsync"
                 @ontouchleave="ClearTouchAsync"
                 id="@ContentElementId"
                 style="@TextEditorStyleCssString"
                 class="bte_text-editor bcrl_unselectable @TextEditorClassCssString"
                 tabindex="-1">

                <MeasureCharacterWidthAndRowHeight @ref="MeasureCharacterWidthAndRowHeightComponent"
                                                   HtmlElementId="@MeasureCharacterWidthAndRowHeightElementId" />

                @if (textEditorModel is not null &&
                textEditorViewModel is not null)
                {
                    @*
                The CascadingValue for textEditorModel and textEditorViewModel need to be here.
                If outside the if not null checks they can cascade a null value to a component which expects a non null.
                *@
                    <CascadingValue Value="textEditorModel">
                        <CascadingValue Value="textEditorViewModel">
                            <GutterSection />

                            <BodySection @ref="_bodySection"
                                     TabIndex="TabIndex"
                                     ContextMenuRenderFragmentOverride="ContextMenuRenderFragmentOverride"
                                     IncludeContextMenuHelperComponent="IncludeContextMenuHelperComponent"
                                     AutoCompleteMenuRenderFragmentOverride="AutoCompleteMenuRenderFragmentOverride" />

                            @if (textEditorViewModel.DisplayCommandBar)
                            {
                                <CommandBarDisplay RestoreFocusToTextEditor="FocusTextEditorAsync" />
                            }
                        </CascadingValue>
                    </CascadingValue>
                }
                else
                {
                    if (textEditorModel is null)
                    {
                        <div>The @nameof(TextEditorModel) was null</div>
                    }
                    else if (textEditorViewModel is null)
                    {
                        <div>The @nameof(TextEditorViewModel) was null</div>
                    }
                }
            </div>

            @if (IncludeFooterHelperComponent &&
            textEditorModel is not null &&
            textEditorViewModel is not null)
            {
                @*
            The CascadingValue for textEditorModel and textEditorViewModel need to be here.
            If outside the if not null checks they can cascade a null value to a component which expects a non null.
            *@
                <CascadingValue Value="textEditorModel">
                    <CascadingValue Value="textEditorViewModel">
                        <TextEditorFooter TextEditorViewModelKey="TextEditorViewModelKey" />
                    </CascadingValue>
                </CascadingValue>
            }

        </CascadingValue>
    </CascadingValue>
</div>